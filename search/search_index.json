{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 \ud83d\udcd8 Projectile Motion: Investigating Range as a Function of Angle \ud83c\udfaf 1. Theoretical Background Projectile motion describes the motion of an object thrown into the air, subject only to gravitational acceleration. \ud83e\uddee Equations of Motion The motion is broken into two components: \u25cb Horizontal (x-axis) \u25cb Vertical (y-axis) Initial velocity components: \\(v_{0x} = v_0 \\cos(\\theta)\\) \\(v_{0y} = v_0 \\sin(\\theta)\\) Position functions: \\(x(t) = v_0 \\cos(\\theta) \\cdot t\\) \\(y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2\\) \u23f1\ufe0f Time of Flight For a projectile launched and landing at the same height: \\(T = \\frac{2v_0 \\sin(\\theta)}{g}\\) \ud83d\udccf Horizontal Range Using time of flight in the x-position: \\(R = v_{0x} \\cdot T\\) \\(R = \\frac{v_0^2 \\sin(2\\theta)}{g}\\) Range is maximum when \\(\\theta = 45^\\circ\\) because \\(\\sin(2\\theta)\\) is maximum at \\(90^\\circ\\) . \ud83d\udcca 2. Detailed Python Simulation \ud83d\udca1 Objective Simulate and visualize how the range changes with projection angle. Also show effects of varying initial speed and gravity. import numpy as np import matplotlib.pyplot as plt # Define function to calculate range def calculate_range(v0, g, angles_deg): angles_rad = np.radians(angles_deg) return (v0**2 * np.sin(2 * angles_rad)) / g # Parameters g = 9.81 # Earth gravity (m/s^2) angles = np.linspace(0, 90, 500) # Different initial speeds v0_values = [10, 20, 30, 40] plt.figure(figsize=(10, 6)) # Plot for each v0 for v0 in v0_values: R = calculate_range(v0, g, angles) plt.plot(angles, R, label=f'v\u2080 = {v0} m/s') plt.title(\"Range vs Angle of Projection for Different Initial Velocities\") plt.xlabel(\"Angle (degrees)\") plt.ylabel(\"Range (meters)\") plt.grid(True) plt.legend() plt.tight_layout() plt.show() \ud83d\udd0d 3. Parameters and Their Effects Parameter Symbol Effect on Range Initial Velocity v 0 R \u221d v 0 2 \u2192 Quadratic increase Gravity g R \u221d 1/g \u2192 Inversely related Angle \u03b8 R \u221d sin(2\u03b8) \u2192 Max at 45\u00b0 \ud83c\udf10 4. Real-World Adaptations \ud83c\udfd4 Uneven Terrain If the launch and landing heights differ (e.g., launched from a cliff or building), the vertical motion equation becomes: \\[ y(t) = v_0 \\sin(\\theta)t - \\frac{1}{2}gt^2 \\] \\[ y(t) = v_0 \\sin(\\theta)t - \\frac{1}{2}gt^2 \\] \ud83d\udca8 With Air Resistance Introduce drag force: \\(F_d = -kv\\) (linear) or \\(F_d = -kv^2\\) (quadratic) \ud83d\udea7 6. Limitations & Future Improvements Limitation How to Improve No air resistance Add drag force and solve numerically Constant gravity Use variable g(h) for high-altitude launches Flat terrain Model terrain using piecewise height functions 2D only Extend to 3D with azimuthal angle for full realism \u2705 Conclusion Projectile motion is a powerful model that reveals deep physical insights using relatively simple mathematics. By changing angle, speed, and environment, we unlock a vast space of real-world applications \u2014 from sports to space science.","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#projectile-motion-investigating-range-as-a-function-of-angle","text":"","title":"\ud83d\udcd8 Projectile Motion: Investigating Range as a Function of Angle"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-background","text":"Projectile motion describes the motion of an object thrown into the air, subject only to gravitational acceleration.","title":"\ud83c\udfaf 1. Theoretical Background"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#equations-of-motion","text":"The motion is broken into two components: \u25cb Horizontal (x-axis) \u25cb Vertical (y-axis)","title":"\ud83e\uddee Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#initial-velocity-components","text":"\\(v_{0x} = v_0 \\cos(\\theta)\\) \\(v_{0y} = v_0 \\sin(\\theta)\\) Position functions: \\(x(t) = v_0 \\cos(\\theta) \\cdot t\\) \\(y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2\\)","title":"Initial velocity components:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#time-of-flight","text":"For a projectile launched and landing at the same height: \\(T = \\frac{2v_0 \\sin(\\theta)}{g}\\)","title":"\u23f1\ufe0f Time of Flight"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#horizontal-range","text":"Using time of flight in the x-position: \\(R = v_{0x} \\cdot T\\) \\(R = \\frac{v_0^2 \\sin(2\\theta)}{g}\\) Range is maximum when \\(\\theta = 45^\\circ\\) because \\(\\sin(2\\theta)\\) is maximum at \\(90^\\circ\\) .","title":"\ud83d\udccf Horizontal Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-detailed-python-simulation","text":"\ud83d\udca1 Objective Simulate and visualize how the range changes with projection angle. Also show effects of varying initial speed and gravity. import numpy as np import matplotlib.pyplot as plt # Define function to calculate range def calculate_range(v0, g, angles_deg): angles_rad = np.radians(angles_deg) return (v0**2 * np.sin(2 * angles_rad)) / g # Parameters g = 9.81 # Earth gravity (m/s^2) angles = np.linspace(0, 90, 500) # Different initial speeds v0_values = [10, 20, 30, 40] plt.figure(figsize=(10, 6)) # Plot for each v0 for v0 in v0_values: R = calculate_range(v0, g, angles) plt.plot(angles, R, label=f'v\u2080 = {v0} m/s') plt.title(\"Range vs Angle of Projection for Different Initial Velocities\") plt.xlabel(\"Angle (degrees)\") plt.ylabel(\"Range (meters)\") plt.grid(True) plt.legend() plt.tight_layout() plt.show() \ud83d\udd0d 3. Parameters and Their Effects Parameter Symbol Effect on Range Initial Velocity v 0 R \u221d v 0 2 \u2192 Quadratic increase Gravity g R \u221d 1/g \u2192 Inversely related Angle \u03b8 R \u221d sin(2\u03b8) \u2192 Max at 45\u00b0","title":"\ud83d\udcca 2. Detailed Python Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-real-world-adaptations","text":"","title":"\ud83c\udf10 4. Real-World Adaptations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#uneven-terrain","text":"If the launch and landing heights differ (e.g., launched from a cliff or building), the vertical motion equation becomes: \\[ y(t) = v_0 \\sin(\\theta)t - \\frac{1}{2}gt^2 \\] \\[ y(t) = v_0 \\sin(\\theta)t - \\frac{1}{2}gt^2 \\]","title":"\ud83c\udfd4 Uneven Terrain"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#with-air-resistance","text":"Introduce drag force: \\(F_d = -kv\\) (linear) or \\(F_d = -kv^2\\) (quadratic)","title":"\ud83d\udca8 With Air Resistance"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#6-limitations-future-improvements","text":"Limitation How to Improve No air resistance Add drag force and solve numerically Constant gravity Use variable g(h) for high-altitude launches Flat terrain Model terrain using piecewise height functions 2D only Extend to 3D with azimuthal angle for full realism \u2705 Conclusion Projectile motion is a powerful model that reveals deep physical insights using relatively simple mathematics. By changing angle, speed, and environment, we unlock a vast space of real-world applications \u2014 from sports to space science.","title":"\ud83d\udea7 6. Limitations &amp; Future Improvements"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 \ud83c\udf00 Investigating the Dynamics of a Forced Damped Pendulum \ud83d\udccc Motivation The forced damped pendulum illustrates how the simple motion of a pendulum becomes drastically more complex when damping and external forcing are introduced. These interactions give rise to phenomena such as: Resonance A phenomenon where a system oscillates at maximum amplitude when driven at its natural frequency. Quasiperiodic Motion Motion that results from the combination of two or more incommensurate frequencies, leading to a complex but non-chaotic behavior. Chaos A state of unpredictable, irregular motion that occurs when a system is highly sensitive to initial conditions, often seen when driving forces are close to resonant frequencies. Applications of this model span: Climate Systems: Understanding complex cycles and feedback loops within climate dynamics. Oscillating Circuits: Used in electrical engineering, particularly in resonance circuits. Energy Harvesting: Devices like piezoelectric generators, where oscillating systems harvest energy from environmental vibrations. Structural Dynamics: Studying vibrations and oscillations in structures such as bridges, buildings, and mechanical systems. \ud83e\udde0 1. Theoretical Foundation \ud83d\udd27 Governing Equation The equation of motion for a forced, damped pendulum is: $$ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t) $$ Where: \\(\\theta(t)\\) : Angular displacement \\(\\gamma\\) : Damping coefficient \\(\\omega_0\\) : Natural frequency \\((\\omega_0 = \\sqrt{g/L})\\) \\(A\\) : Amplitude of the driving force \\(\\omega\\) : Driving frequency \u2705 Small-Angle Approximation If \\(\\theta\\) is small: $$ \\sin(\\theta) \\approx \\theta $$ $$ \\Rightarrow \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) $$ This is a linear second-order differential equation solvable using standard methods (e.g., undetermined coefficients). \ud83d\udcca 2. Analysis of Dynamics \ud83d\udd01 Parameter Influence Parameter Symbol Effect Damping \u03b3 Reduces amplitude, suppresses chaos at high values Driving amplitude A Higher A can induce chaotic behavior Driving frequency \u03c9 Controls resonance and synchronization \ud83d\udd04 Regular vs. Chaotic Motion \u25cb At low forcing: periodic or quasiperiodic motion \u25cb At certain parameter ranges: chaotic behavior, sensitive to initial conditions \u25cb Visual tools: Phase space, Poincar\u00e9 sections, Bifurcation diagrams \ud83c\udf0d 3. Practical Applications The forced damped pendulum model applies to many real systems: Field Example Mechanical Suspension bridges, vibration absorbers Electrical Driven RLC circuits Biomechanics Human locomotion (gait dynamics) Renewable energy Pendulum wave energy converters \ud83d\udc0d Python Code import numpy as np import matplotlib.pyplot as plt # Parameters gamma = 0.2 # damping coefficient omega0 = 1.5 # natural frequency A = 1.2 # driving amplitude omega = 0.8 # driving frequency # Time parameters t_max = 100 # maximum time dt = 0.01 # time step n_steps = int(t_max / dt) # number of time steps # Initial conditions theta_0 = 0.1 # initial angle (radians) v_0 = 0.0 # initial angular velocity # Initialize arrays to store results t = np.linspace(0, t_max, n_steps) theta = np.zeros(n_steps) v = np.zeros(n_steps) # Set initial conditions theta[0] = theta_0 v[0] = v_0 # Verlet method to solve the equations for i in range(1, n_steps-1): # Compute the acceleration at current position a = -gamma * v[i-1] - omega0**2 * np.sin(theta[i-1]) + A * np.cos(omega * t[i-1]) # Use the Verlet update rule theta[i+1] = 2 * theta[i] - theta[i-1] + a * dt**2 v[i+1] = (theta[i+1] - theta[i-1]) / (2 * dt) # Velocity is the derivative of position # Plot the results plt.figure(figsize=(10, 4)) plt.plot(t, theta) plt.title(\"Angular Displacement of Forced Damped Pendulum (Verlet Method)\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Theta (radians)\") plt.grid(True) plt.show() \u26a0\ufe0f Limitations and Extensions Limitation Suggested Extension Small-angle approximation Use full &sin;(\u03b8) for large oscillations Linear damping only Add nonlinear damping terms Periodic forcing only Try quasiperiodic or random driving 2D model Extend to double pendulum or 3D Conclusion: \u25cb The forced damped pendulum model offers valuable insights into the behavior of oscillating systems, ranging from simple harmonic motion to chaotic dynamics. By studying phenomena such as resonance, quasiperiodic motion, and chaos, this model provides a framework for understanding complex real-world systems. Its applications span various fields, including climate systems, oscillating circuits, energy harvesting, and structural dynamics, making it a versatile tool for both theoretical analysis and practical engineering solutions.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"\ud83c\udf00 Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#motivation","text":"The forced damped pendulum illustrates how the simple motion of a pendulum becomes drastically more complex when damping and external forcing are introduced. These interactions give rise to phenomena such as:","title":"\ud83d\udccc Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance","text":"A phenomenon where a system oscillates at maximum amplitude when driven at its natural frequency.","title":"Resonance"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#quasiperiodic-motion","text":"Motion that results from the combination of two or more incommensurate frequencies, leading to a complex but non-chaotic behavior.","title":"Quasiperiodic Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#chaos","text":"A state of unpredictable, irregular motion that occurs when a system is highly sensitive to initial conditions, often seen when driving forces are close to resonant frequencies.","title":"Chaos"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#applications-of-this-model-span","text":"Climate Systems: Understanding complex cycles and feedback loops within climate dynamics. Oscillating Circuits: Used in electrical engineering, particularly in resonance circuits. Energy Harvesting: Devices like piezoelectric generators, where oscillating systems harvest energy from environmental vibrations. Structural Dynamics: Studying vibrations and oscillations in structures such as bridges, buildings, and mechanical systems.","title":"Applications of this model span:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"","title":"\ud83e\udde0 1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#governing-equation","text":"The equation of motion for a forced, damped pendulum is: $$ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t) $$ Where: \\(\\theta(t)\\) : Angular displacement \\(\\gamma\\) : Damping coefficient \\(\\omega_0\\) : Natural frequency \\((\\omega_0 = \\sqrt{g/L})\\) \\(A\\) : Amplitude of the driving force \\(\\omega\\) : Driving frequency","title":"\ud83d\udd27 Governing Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"If \\(\\theta\\) is small: $$ \\sin(\\theta) \\approx \\theta $$ $$ \\Rightarrow \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) $$ This is a linear second-order differential equation solvable using standard methods (e.g., undetermined coefficients).","title":"\u2705 Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"\ud83d\udd01 Parameter Influence Parameter Symbol Effect Damping \u03b3 Reduces amplitude, suppresses chaos at high values Driving amplitude A Higher A can induce chaotic behavior Driving frequency \u03c9 Controls resonance and synchronization","title":"\ud83d\udcca 2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#regular-vs-chaotic-motion","text":"\u25cb At low forcing: periodic or quasiperiodic motion \u25cb At certain parameter ranges: chaotic behavior, sensitive to initial conditions \u25cb Visual tools: Phase space, Poincar\u00e9 sections, Bifurcation diagrams","title":"\ud83d\udd04 Regular vs. Chaotic Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"The forced damped pendulum model applies to many real systems: Field Example Mechanical Suspension bridges, vibration absorbers Electrical Driven RLC circuits Biomechanics Human locomotion (gait dynamics) Renewable energy Pendulum wave energy converters","title":"\ud83c\udf0d 3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#python-code","text":"import numpy as np import matplotlib.pyplot as plt # Parameters gamma = 0.2 # damping coefficient omega0 = 1.5 # natural frequency A = 1.2 # driving amplitude omega = 0.8 # driving frequency # Time parameters t_max = 100 # maximum time dt = 0.01 # time step n_steps = int(t_max / dt) # number of time steps # Initial conditions theta_0 = 0.1 # initial angle (radians) v_0 = 0.0 # initial angular velocity # Initialize arrays to store results t = np.linspace(0, t_max, n_steps) theta = np.zeros(n_steps) v = np.zeros(n_steps) # Set initial conditions theta[0] = theta_0 v[0] = v_0 # Verlet method to solve the equations for i in range(1, n_steps-1): # Compute the acceleration at current position a = -gamma * v[i-1] - omega0**2 * np.sin(theta[i-1]) + A * np.cos(omega * t[i-1]) # Use the Verlet update rule theta[i+1] = 2 * theta[i] - theta[i-1] + a * dt**2 v[i+1] = (theta[i+1] - theta[i-1]) / (2 * dt) # Velocity is the derivative of position # Plot the results plt.figure(figsize=(10, 4)) plt.plot(t, theta) plt.title(\"Angular Displacement of Forced Damped Pendulum (Verlet Method)\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Theta (radians)\") plt.grid(True) plt.show()","title":"\ud83d\udc0d Python Code"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#limitations-and-extensions","text":"Limitation Suggested Extension Small-angle approximation Use full &sin;(\u03b8) for large oscillations Linear damping only Add nonlinear damping terms Periodic forcing only Try quasiperiodic or random driving 2D model Extend to double pendulum or 3D","title":"\u26a0\ufe0f Limitations and Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#conclusion","text":"\u25cb The forced damped pendulum model offers valuable insights into the behavior of oscillating systems, ranging from simple harmonic motion to chaotic dynamics. By studying phenomena such as resonance, quasiperiodic motion, and chaos, this model provides a framework for understanding complex real-world systems. Its applications span various fields, including climate systems, oscillating circuits, energy harvesting, and structural dynamics, making it a versatile tool for both theoretical analysis and practical engineering solutions.","title":"Conclusion:"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Orbital Period and Orbital Radius Motivation: The relationship between the square of the orbital period and the cube of the orbital radius, known as Kepler's Third Law , is a cornerstone of celestial mechanics. This simple yet profound relationship allows for the determination of planetary motions and has implications for understanding gravitational interactions on both local and cosmic scales. By analyzing this relationship, one can connect fundamental principles of gravity with real-world phenomena such as satellite orbits and planetary systems. Kepler's Third Law Derivation: Kepler's Third Law states that the square of the orbital period \\(T\\) is proportional to the cube of the orbital radius \\(r\\) for circular orbits: \\[ T^2 \\propto r^3 \\] This law can be derived using Newton's law of gravitation and centripetal force. For an object orbiting a planet in a circular orbit, the centripetal force required to keep the object in orbit is provided by the gravitational force between the object and the planet. The gravitational force is given by: \\[ F_{\\text{gravity}} = \\frac{G M m}{r^2} \\] Where: - \\( G \\) is the gravitational constant, - \\( M \\) is the mass of the planet, - \\( m \\) is the mass of the orbiting object, - \\( r \\) is the orbital radius. The centripetal force is given by: \\[ F_{\\text{centripetal}} = \\frac{m v^2}{r} \\] Where \\( v \\) is the orbital velocity. Setting these two forces equal to each other: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Simplifying: \\[ v^2 = \\frac{G M}{r} \\] The orbital velocity is related to the orbital period \\( T \\) by: \\[ v = \\frac{2 \\pi r}{T} \\] Substituting \\( v \\) into the equation for \\( v^2 \\) : \\[ \\left( \\frac{2 \\pi r}{T} \\right)^2 = \\frac{G M}{r} \\] Simplifying: \\[ \\frac{4 \\pi^2 r^2}{T^2} = \\frac{G M}{r} \\] Rearranging: \\[ T^2 = \\frac{4 \\pi^2 r^3}{G M} \\] Thus, we have derived the relationship between the orbital period and the orbital radius: \\[ T^2 \\propto r^3 \\] This equation shows that the square of the orbital period is proportional to the cube of the orbital radius, confirming Kepler's Third Law. Implications for Astronomy: Planetary Orbits : Kepler's Third Law allows astronomers to calculate the orbital periods and distances of planets in the solar system. Satellite Orbits : For artificial satellites, this law helps determine the required altitude for desired orbital periods. Gravitational Interactions : The law is crucial for understanding the dynamics of celestial bodies, including moons, planets, and even exoplanets in distant star systems. Real-World Examples: The Moon's Orbit Around Earth : The Moon's orbital period is approximately 27.3 days, and its orbital radius is about 384,400 km. Using Kepler's Third Law, we can calculate the mass of the Earth from the orbital characteristics of the Moon. Orbits of Planets in the Solar System : The relationship between the orbital period and radius is essential for understanding the motions of planets around the Sun. For example, Earth has an orbital period of 365.25 days and a radius of about 149.6 million km. Using Kepler's Law, we can also estimate the mass of the Sun. Computational Model: We can implement a Python script to simulate circular orbits and visualize the relationship between orbital period and radius. Below is the Python code that computes and plots the orbital period for different orbital radii: import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant in m^3 kg^-1 s^-2 M = 5.972e24 # Mass of Earth in kg # Orbital radii in meters radii = np.linspace(1e7, 1e8, 100) # From 10,000 km to 100,000 km # Calculate the orbital period using Kepler's Third Law periods = np.sqrt((4 * np.pi**2 * radii**3) / (G * M)) # Plot the orbital period vs radius plt.figure(figsize=(8, 6)) plt.plot(radii, periods / 3600 / 24, label=\"Orbital Period\", color='b') # Convert period to days plt.xlabel(\"Orbital Radius (m)\") plt.ylabel(\"Orbital Period (days)\") plt.title(\"Orbital Period vs Orbital Radius\") plt.grid(True) plt.legend() plt.show() Explanation: Kepler's Third Law: We use the derived formula \\[ T^2 = \\frac{4 \\pi^2 r^3}{G M} \\] to compute the orbital period. Plot: The graph shows how the orbital period increases with the cube of the orbital radius, confirming Kepler's Third Law. Extension to Elliptical Orbits: Kepler's Third Law is also valid for elliptical orbits, but the relationship between the orbital period and the orbital radius must be considered in terms of the semi-major axis of the ellipse. For elliptical orbits, the law can be written as: \\[ T^2 \\propto a^3 \\] Where \\(a\\) is the semi-major axis of the ellipse, which is the average of the closest and farthest distances from the central body. Conclusion: Kepler's Third Law provides a powerful tool for understanding the motion of celestial bodies. By relating the orbital period to the cube of the orbital radius, we can predict planetary positions, calculate planetary masses, and study gravitational interactions. This law is essential for both theoretical and practical applications in astronomy, satellite communications, and space exploration.","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius","text":"","title":"Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#motivation","text":"The relationship between the square of the orbital period and the cube of the orbital radius, known as Kepler's Third Law , is a cornerstone of celestial mechanics. This simple yet profound relationship allows for the determination of planetary motions and has implications for understanding gravitational interactions on both local and cosmic scales. By analyzing this relationship, one can connect fundamental principles of gravity with real-world phenomena such as satellite orbits and planetary systems.","title":"Motivation:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#keplers-third-law-derivation","text":"Kepler's Third Law states that the square of the orbital period \\(T\\) is proportional to the cube of the orbital radius \\(r\\) for circular orbits: \\[ T^2 \\propto r^3 \\] This law can be derived using Newton's law of gravitation and centripetal force. For an object orbiting a planet in a circular orbit, the centripetal force required to keep the object in orbit is provided by the gravitational force between the object and the planet. The gravitational force is given by: \\[ F_{\\text{gravity}} = \\frac{G M m}{r^2} \\] Where: - \\( G \\) is the gravitational constant, - \\( M \\) is the mass of the planet, - \\( m \\) is the mass of the orbiting object, - \\( r \\) is the orbital radius. The centripetal force is given by: \\[ F_{\\text{centripetal}} = \\frac{m v^2}{r} \\] Where \\( v \\) is the orbital velocity. Setting these two forces equal to each other: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Simplifying: \\[ v^2 = \\frac{G M}{r} \\] The orbital velocity is related to the orbital period \\( T \\) by: \\[ v = \\frac{2 \\pi r}{T} \\] Substituting \\( v \\) into the equation for \\( v^2 \\) : \\[ \\left( \\frac{2 \\pi r}{T} \\right)^2 = \\frac{G M}{r} \\] Simplifying: \\[ \\frac{4 \\pi^2 r^2}{T^2} = \\frac{G M}{r} \\] Rearranging: \\[ T^2 = \\frac{4 \\pi^2 r^3}{G M} \\] Thus, we have derived the relationship between the orbital period and the orbital radius: \\[ T^2 \\propto r^3 \\] This equation shows that the square of the orbital period is proportional to the cube of the orbital radius, confirming Kepler's Third Law.","title":"Kepler's Third Law Derivation:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#implications-for-astronomy","text":"Planetary Orbits : Kepler's Third Law allows astronomers to calculate the orbital periods and distances of planets in the solar system. Satellite Orbits : For artificial satellites, this law helps determine the required altitude for desired orbital periods. Gravitational Interactions : The law is crucial for understanding the dynamics of celestial bodies, including moons, planets, and even exoplanets in distant star systems.","title":"Implications for Astronomy:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#real-world-examples","text":"The Moon's Orbit Around Earth : The Moon's orbital period is approximately 27.3 days, and its orbital radius is about 384,400 km. Using Kepler's Third Law, we can calculate the mass of the Earth from the orbital characteristics of the Moon. Orbits of Planets in the Solar System : The relationship between the orbital period and radius is essential for understanding the motions of planets around the Sun. For example, Earth has an orbital period of 365.25 days and a radius of about 149.6 million km. Using Kepler's Law, we can also estimate the mass of the Sun.","title":"Real-World Examples:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#computational-model","text":"We can implement a Python script to simulate circular orbits and visualize the relationship between orbital period and radius. Below is the Python code that computes and plots the orbital period for different orbital radii: import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant in m^3 kg^-1 s^-2 M = 5.972e24 # Mass of Earth in kg # Orbital radii in meters radii = np.linspace(1e7, 1e8, 100) # From 10,000 km to 100,000 km # Calculate the orbital period using Kepler's Third Law periods = np.sqrt((4 * np.pi**2 * radii**3) / (G * M)) # Plot the orbital period vs radius plt.figure(figsize=(8, 6)) plt.plot(radii, periods / 3600 / 24, label=\"Orbital Period\", color='b') # Convert period to days plt.xlabel(\"Orbital Radius (m)\") plt.ylabel(\"Orbital Period (days)\") plt.title(\"Orbital Period vs Orbital Radius\") plt.grid(True) plt.legend() plt.show()","title":"Computational Model:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#explanation","text":"Kepler's Third Law: We use the derived formula \\[ T^2 = \\frac{4 \\pi^2 r^3}{G M} \\] to compute the orbital period. Plot: The graph shows how the orbital period increases with the cube of the orbital radius, confirming Kepler's Third Law.","title":"Explanation:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#extension-to-elliptical-orbits","text":"Kepler's Third Law is also valid for elliptical orbits, but the relationship between the orbital period and the orbital radius must be considered in terms of the semi-major axis of the ellipse. For elliptical orbits, the law can be written as: \\[ T^2 \\propto a^3 \\] Where \\(a\\) is the semi-major axis of the ellipse, which is the average of the closest and farthest distances from the central body.","title":"Extension to Elliptical Orbits:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#conclusion","text":"Kepler's Third Law provides a powerful tool for understanding the motion of celestial bodies. By relating the orbital period to the cube of the orbital radius, we can predict planetary positions, calculate planetary masses, and study gravitational interactions. This law is essential for both theoretical and practical applications in astronomy, satellite communications, and space exploration.","title":"Conclusion:"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Escape Velocities and Cosmic Velocities Motivation: The concept of escape velocity is crucial for understanding the conditions required to leave a celestial body's gravitational influence. Extending this concept, the first, second, and third cosmic velocities define the thresholds for orbiting, escaping, and leaving a star system. These principles underpin modern space exploration, from launching satellites to interplanetary missions. Task: Define the first, second, and third cosmic velocities , explaining their physical meaning. Analyze the mathematical derivations and parameters affecting these velocities. Calculate and visualize these velocities for different celestial bodies like Earth, Mars, and Jupiter. Discuss their importance in space exploration , including launching satellites, missions to other planets, and potential interstellar travel. Explanation: Escape Velocity: The escape velocity is the minimum speed an object needs to escape from the gravitational influence of a celestial body without further propulsion. The formula for escape velocity is derived from equating the kinetic energy of an object to the gravitational potential energy: \\[ v_e = \\sqrt{\\frac{2 G M}{r}} \\] Where: \\( v_e \\) is the escape velocity, \\( G \\) is the gravitational constant, \\( M \\) is the mass of the celestial body, \\( r \\) is the distance from the center of the body (usually the surface radius). First Cosmic Velocity (Orbital Velocity): The first cosmic velocity is the minimum velocity an object needs to enter a circular orbit around a celestial body. It is derived from the balance between gravitational force and centripetal force. The formula is: \\[ v_1 = \\sqrt{\\frac{G M}{r}} \\] Where: \\( v_1 \\) is the orbital velocity (first cosmic velocity), \\( G \\) is the gravitational constant, \\( M \\) is the mass of the celestial body, \\( r \\) is the radius of the orbit. Second Cosmic Velocity (Escape Velocity): The second cosmic velocity is the escape velocity, already discussed above. It is the velocity required to break free from a celestial body\u2019s gravitational pull without further propulsion. \\[ v_2 = \\sqrt{\\frac{2 G M}{r}} \\] Where: \\( v_2 \\) is the escape velocity, same as the formula for escape velocity. Third Cosmic Velocity (Escape from the Solar System): The third cosmic velocity is the velocity needed for an object to escape the gravitational influence of a star, specifically the Sun in the case of our solar system. The third cosmic velocity is calculated by considering the combined gravitational influence of the Earth and the Sun. It is derived from the total energy of the object relative to both bodies: \\[ v_3 = \\sqrt{\\frac{2 G M_{\\text{sun}}}{r_{\\text{sun}}} + \\frac{2 G M_{\\text{earth}}}{r_{\\text{earth}}}} \\] Where: \\( v_3 \\) is the third cosmic velocity, \\( M_{\\text{sun}} \\) and \\( M_{\\text{earth}} \\) are the masses of the Sun and the Earth, \\( r_{\\text{sun}} \\) and \\( r_{\\text{earth}} \\) are the distances of the object from the Sun and Earth respectively. Calculations for Different Celestial Bodies: We can calculate the first, second, and third cosmic velocities for celestial bodies like Earth, Mars, and Jupiter. Below are their key values: Earth Mass (M earth ): 5.972 \u00d7 10 24 kg Radius (r earth ): 6.371 \u00d7 10 6 m Mars Mass (M mars ): 0.64171 \u00d7 10 24 kg Radius (r mars ): 3.396 \u00d7 10 6 m Jupiter Mass (M jupiter ): 1.898 \u00d7 10 27 kg Radius (r jupiter ): 6.991 \u00d7 10 7 m Python Implementation: To compute these velocities for various celestial bodies, we can implement the following Python code using the formulas above: import math # Constants G = 6.67430e-11 # Gravitational constant in m^3 kg^-1 s^-2 # Function to calculate escape velocity def escape_velocity(M, r): return math.sqrt((2 * G * M) / r) # Function to calculate orbital velocity (first cosmic velocity) def orbital_velocity(M, r): return math.sqrt((G * M) / r) # Calculate velocities for Earth, Mars, and Jupiter celestial_bodies = { 'Earth': {'M': 5.972e24, 'r': 6.371e6}, 'Mars': {'M': 0.64171e24, 'r': 3.396e6}, 'Jupiter': {'M': 1.898e27, 'r': 6.991e7} } for body, values in celestial_bodies.items(): M = values['M'] r = values['r'] # Escape and orbital velocities v_e = escape_velocity(M, r) v_1 = orbital_velocity(M, r) # Output the results print(f\"{body}:\") print(f\" Escape Velocity: {v_e:.2f} m/s\") print(f\" Orbital Velocity (First Cosmic): {v_1:.2f} m/s\") print() Print Results Celestial Body Escape Velocity (m/s) Orbital Velocity (First Cosmic Velocity, m/s) Earth 11,185.98 m/s 7,909.68 m/s Mars 5,022.31 m/s 3,551.31 m/s Jupiter 60,199.98 m/s 42,567.81 m/s Conclusion: The first, second, and third cosmic velocities are crucial for understanding the dynamics of space travel. The escape velocity determines the speed needed to break free from a celestial body\u2019s gravitational pull, while the orbital velocity is necessary to remain in orbit. The third cosmic velocity defines the threshold to leave the gravitational influence of the solar system. These velocities play a central role in space exploration, from launching satellites to interplanetary missions. Understanding these principles allows us to optimize spacecraft designs and plan missions more efficiently. Deliverables: A detailed explanation of escape velocities and cosmic velocities, as well as the mathematical derivations. Python code to compute and visualize the escape velocities and orbital velocities for different celestial bodies. Graphical representation showing how the escape velocity and orbital velocity vary for Earth, Mars, and Jupiter. \"Escape and Cosmic Velocities for Various Celestial Bodies\" Celestial Body Escape Velocity (m/s) Orbital Velocity (First Cosmic Velocity, m/s) Second Cosmic Velocity (m/s) Third Cosmic Velocity (m/s) Earth 11,186 m/s 7,909 m/s 15,711 m/s 42,100 m/s Mars 5,027 m/s 3,554 m/s 7,107 m/s 21,800 m/s Jupiter 60,200 m/s 42,100 m/s 84,200 m/s 212,000 m/s","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#motivation","text":"The concept of escape velocity is crucial for understanding the conditions required to leave a celestial body's gravitational influence. Extending this concept, the first, second, and third cosmic velocities define the thresholds for orbiting, escaping, and leaving a star system. These principles underpin modern space exploration, from launching satellites to interplanetary missions.","title":"Motivation:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#task","text":"Define the first, second, and third cosmic velocities , explaining their physical meaning. Analyze the mathematical derivations and parameters affecting these velocities. Calculate and visualize these velocities for different celestial bodies like Earth, Mars, and Jupiter. Discuss their importance in space exploration , including launching satellites, missions to other planets, and potential interstellar travel.","title":"Task:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#explanation","text":"","title":"Explanation:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocity","text":"The escape velocity is the minimum speed an object needs to escape from the gravitational influence of a celestial body without further propulsion. The formula for escape velocity is derived from equating the kinetic energy of an object to the gravitational potential energy: \\[ v_e = \\sqrt{\\frac{2 G M}{r}} \\] Where: \\( v_e \\) is the escape velocity, \\( G \\) is the gravitational constant, \\( M \\) is the mass of the celestial body, \\( r \\) is the distance from the center of the body (usually the surface radius).","title":"Escape Velocity:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#first-cosmic-velocity-orbital-velocity","text":"The first cosmic velocity is the minimum velocity an object needs to enter a circular orbit around a celestial body. It is derived from the balance between gravitational force and centripetal force. The formula is: \\[ v_1 = \\sqrt{\\frac{G M}{r}} \\] Where: \\( v_1 \\) is the orbital velocity (first cosmic velocity), \\( G \\) is the gravitational constant, \\( M \\) is the mass of the celestial body, \\( r \\) is the radius of the orbit.","title":"First Cosmic Velocity (Orbital Velocity):"},{"location":"1%20Physics/2%20Gravity/Problem_2/#second-cosmic-velocity-escape-velocity","text":"The second cosmic velocity is the escape velocity, already discussed above. It is the velocity required to break free from a celestial body\u2019s gravitational pull without further propulsion. \\[ v_2 = \\sqrt{\\frac{2 G M}{r}} \\] Where: \\( v_2 \\) is the escape velocity, same as the formula for escape velocity.","title":"Second Cosmic Velocity (Escape Velocity):"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity-escape-from-the-solar-system","text":"The third cosmic velocity is the velocity needed for an object to escape the gravitational influence of a star, specifically the Sun in the case of our solar system. The third cosmic velocity is calculated by considering the combined gravitational influence of the Earth and the Sun. It is derived from the total energy of the object relative to both bodies: \\[ v_3 = \\sqrt{\\frac{2 G M_{\\text{sun}}}{r_{\\text{sun}}} + \\frac{2 G M_{\\text{earth}}}{r_{\\text{earth}}}} \\] Where: \\( v_3 \\) is the third cosmic velocity, \\( M_{\\text{sun}} \\) and \\( M_{\\text{earth}} \\) are the masses of the Sun and the Earth, \\( r_{\\text{sun}} \\) and \\( r_{\\text{earth}} \\) are the distances of the object from the Sun and Earth respectively.","title":"Third Cosmic Velocity (Escape from the Solar System):"},{"location":"1%20Physics/2%20Gravity/Problem_2/#calculations-for-different-celestial-bodies","text":"We can calculate the first, second, and third cosmic velocities for celestial bodies like Earth, Mars, and Jupiter. Below are their key values:","title":"Calculations for Different Celestial Bodies:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-implementation","text":"To compute these velocities for various celestial bodies, we can implement the following Python code using the formulas above: import math # Constants G = 6.67430e-11 # Gravitational constant in m^3 kg^-1 s^-2 # Function to calculate escape velocity def escape_velocity(M, r): return math.sqrt((2 * G * M) / r) # Function to calculate orbital velocity (first cosmic velocity) def orbital_velocity(M, r): return math.sqrt((G * M) / r) # Calculate velocities for Earth, Mars, and Jupiter celestial_bodies = { 'Earth': {'M': 5.972e24, 'r': 6.371e6}, 'Mars': {'M': 0.64171e24, 'r': 3.396e6}, 'Jupiter': {'M': 1.898e27, 'r': 6.991e7} } for body, values in celestial_bodies.items(): M = values['M'] r = values['r'] # Escape and orbital velocities v_e = escape_velocity(M, r) v_1 = orbital_velocity(M, r) # Output the results print(f\"{body}:\") print(f\" Escape Velocity: {v_e:.2f} m/s\") print(f\" Orbital Velocity (First Cosmic): {v_1:.2f} m/s\") print()","title":"Python Implementation:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#print-results","text":"Celestial Body Escape Velocity (m/s) Orbital Velocity (First Cosmic Velocity, m/s) Earth 11,185.98 m/s 7,909.68 m/s Mars 5,022.31 m/s 3,551.31 m/s Jupiter 60,199.98 m/s 42,567.81 m/s Conclusion: The first, second, and third cosmic velocities are crucial for understanding the dynamics of space travel. The escape velocity determines the speed needed to break free from a celestial body\u2019s gravitational pull, while the orbital velocity is necessary to remain in orbit. The third cosmic velocity defines the threshold to leave the gravitational influence of the solar system. These velocities play a central role in space exploration, from launching satellites to interplanetary missions. Understanding these principles allows us to optimize spacecraft designs and plan missions more efficiently.","title":"Print Results"},{"location":"1%20Physics/2%20Gravity/Problem_2/#deliverables","text":"A detailed explanation of escape velocities and cosmic velocities, as well as the mathematical derivations. Python code to compute and visualize the escape velocities and orbital velocities for different celestial bodies. Graphical representation showing how the escape velocity and orbital velocity vary for Earth, Mars, and Jupiter.","title":"Deliverables:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-and-cosmic-velocities-for-various-celestial-bodies","text":"Celestial Body Escape Velocity (m/s) Orbital Velocity (First Cosmic Velocity, m/s) Second Cosmic Velocity (m/s) Third Cosmic Velocity (m/s) Earth 11,186 m/s 7,909 m/s 15,711 m/s 42,100 m/s Mars 5,027 m/s 3,554 m/s 7,107 m/s 21,800 m/s Jupiter 60,200 m/s 42,100 m/s 84,200 m/s 212,000 m/s","title":"\"Escape and Cosmic Velocities for Various Celestial Bodies\""},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Trajectories of a Freely Released Payload Near Earth Motivation When an object is released from a moving rocket near Earth, its trajectory depends on the initial conditions and gravitational forces acting on it. This problem is a fundamental example of orbital mechanics and offers a rich context to understand how objects move under the influence of gravity. These trajectories are of particular interest for space missions, such as deploying payloads or returning objects to Earth. Understanding the potential outcomes (e.g., parabolic, hyperbolic, elliptical paths) is essential for predicting and planning mission objectives. Trajectories of a Freely Released Payload Near Earth (Possible Types) Here are some common trajectory types you might encounter when releasing a payload near Earth: Parabolic Trajectory : This occurs when the object is launched with a velocity that is equal to the escape velocity for a given distance. The path forms a symmetric curve that eventually returns to Earth. Example: A projectile thrown upwards with an initial velocity such that it just reaches the highest point and falls back to Earth. Elliptical Trajectory : The object moves in a closed orbit around Earth, similar to how satellites orbit the planet. This is the most common trajectory for objects in orbit. Example: A satellite launched into low Earth orbit, where its speed and trajectory are balanced by Earth's gravity. Hyperbolic Trajectory : This occurs when the object is moving fast enough to escape Earth's gravitational influence entirely. The object follows an open curve and will not return to Earth unless acted upon by other forces. Example: A spacecraft launched for interplanetary travel that escapes Earth's gravity and continues its journey through the solar system. Equations of Motion The motion of the payload can be modeled using Newton's law of gravitation: \\[ F = \\frac{GMm}{r^2} \\] Where: \\( F \\) is the gravitational force, \\( G \\) is the gravitational constant ( \\( 6.674 \\times 10^{-11} \\, \\text{N}\\cdot \\text{m}^2/\\text{kg}^2 \\) ), \\( M \\) is the mass of Earth ( \\( 5.972 \\times 10^{24} \\, \\text{kg} \\) ), \\( m \\) is the mass of the payload, \\( r \\) is the distance from the center of the Earth. The resulting trajectory is a solution to the second-order differential equation, where the force \\( F \\) is related to the acceleration of the payload \\( a = \\frac{d^2r}{dt^2} \\) . To solve for the trajectory numerically, we will integrate the equations of motion using Python (or another numerical solver). Example Python Code to Simulate Trajectory import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant in m^3 kg^-1 s^-2 M = 5.972e24 # Mass of Earth in kg R_earth = 6.371e6 # Radius of Earth in meters # Initial conditions r_0 = R_earth + 100000 # Initial position (100 km above Earth's surface) v_0 = 1000 # Initial velocity in m/s (e.g., 1000 m/s upward) # Payload mass (just a placeholder value, can be any mass) m = 1000 # Mass of payload in kg # Time parameters dt = 1 # Time step in seconds t_max = 3600 # Total time in seconds (1 hour) num_steps = int(t_max / dt) # Initialize arrays to store results r = np.zeros(num_steps) # Array to store positions v = np.zeros(num_steps) # Array to store velocities t = np.linspace(0, t_max, num_steps) # Array of time values # Initial conditions r[0] = r_0 v[0] = v_0 # Numerical integration (Euler's method) for i in range(1, num_steps): # Gravitational force (F = G * M * m / r^2) F = -G * M * m / r[i-1]**2 # Force is attractive, hence the negative sign a = F / m # Acceleration due to gravity v[i] = v[i-1] + a * dt # Update velocity r[i] = r[i-1] + v[i-1] * dt # Update position # Stop simulation if the payload crashes into Earth (r < R_earth) if r[i] <= R_earth: print(f\"The payload crashed into Earth at time {t[i]} seconds.\") break # Plot the trajectory (position vs time) plt.plot(t[:i+1], r[:i+1]) # Plot only up to the crash point (if it crashes) plt.xlabel('Time (s)') plt.ylabel('Distance from Earth (m)') plt.title('Trajectory of a Freely Released Payload Near Earth') plt.grid(True) plt.show() Example 1: Escape and Orbital Velocities of Planets Explanation: This table compares the escape and orbital (first cosmic) velocities for Earth, Mars, and Jupiter. These values are critical for satellite launches and interplanetary missions. Planet Escape Velocity (m/s) Orbital Velocity (m/s) Surface Radius (m) Mass (kg) Earth 11185.98 7909.68 6.371 \u00d7 10 6 5.972 \u00d7 10 24 Mars 5022.31 3551.31 3.396 \u00d7 10 6 0.64171 \u00d7 10 24 Jupiter 60199.98 42567.81 6.991 \u00d7 10 7 1.898 \u00d7 10 27 Example 2: Orbit Type Based on Initial Velocity Explanation: The following table shows how different initial velocities determine the type of orbit for a payload released near Earth. Initial Velocity (m/s) Initial Altitude (km) Orbit Type Description 3000 100 Elliptical Payload remains gravitationally bound to Earth. 5000 100 Parabolic Payload reaches escape velocity exactly. 7000 150 Hyperbolic Payload escapes Earth's gravity and continues outward. 8000 200 Parabolic Near escape, marginally hyperbolic trajectory. Example 3: Required Speeds for Orbital Insertion Explanation: This table compares the orbital and escape velocities required at a constant launch altitude for various planets. Planet Orbital Velocity (m/s) Escape Velocity (m/s) Launch Altitude (km) Earth 7909.68 11185.98 100 Mars 3551.31 5022.31 100 Jupiter 42567.81 60199.98 100 Conclusion: Payload trajectories near Earth vary based on initial speed and angle, resulting in orbits, reentry, or escape. Understanding these paths is key for satellite deployment and mission planning, combining gravity, motion laws, and simulation tools.","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#motivation","text":"When an object is released from a moving rocket near Earth, its trajectory depends on the initial conditions and gravitational forces acting on it. This problem is a fundamental example of orbital mechanics and offers a rich context to understand how objects move under the influence of gravity. These trajectories are of particular interest for space missions, such as deploying payloads or returning objects to Earth. Understanding the potential outcomes (e.g., parabolic, hyperbolic, elliptical paths) is essential for predicting and planning mission objectives.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth-possible-types","text":"Here are some common trajectory types you might encounter when releasing a payload near Earth: Parabolic Trajectory : This occurs when the object is launched with a velocity that is equal to the escape velocity for a given distance. The path forms a symmetric curve that eventually returns to Earth. Example: A projectile thrown upwards with an initial velocity such that it just reaches the highest point and falls back to Earth. Elliptical Trajectory : The object moves in a closed orbit around Earth, similar to how satellites orbit the planet. This is the most common trajectory for objects in orbit. Example: A satellite launched into low Earth orbit, where its speed and trajectory are balanced by Earth's gravity. Hyperbolic Trajectory : This occurs when the object is moving fast enough to escape Earth's gravitational influence entirely. The object follows an open curve and will not return to Earth unless acted upon by other forces. Example: A spacecraft launched for interplanetary travel that escapes Earth's gravity and continues its journey through the solar system.","title":"Trajectories of a Freely Released Payload Near Earth (Possible Types)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#equations-of-motion","text":"The motion of the payload can be modeled using Newton's law of gravitation: \\[ F = \\frac{GMm}{r^2} \\] Where: \\( F \\) is the gravitational force, \\( G \\) is the gravitational constant ( \\( 6.674 \\times 10^{-11} \\, \\text{N}\\cdot \\text{m}^2/\\text{kg}^2 \\) ), \\( M \\) is the mass of Earth ( \\( 5.972 \\times 10^{24} \\, \\text{kg} \\) ), \\( m \\) is the mass of the payload, \\( r \\) is the distance from the center of the Earth. The resulting trajectory is a solution to the second-order differential equation, where the force \\( F \\) is related to the acceleration of the payload \\( a = \\frac{d^2r}{dt^2} \\) . To solve for the trajectory numerically, we will integrate the equations of motion using Python (or another numerical solver).","title":"Equations of Motion"},{"location":"1%20Physics/2%20Gravity/Problem_3/#example-python-code-to-simulate-trajectory","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant in m^3 kg^-1 s^-2 M = 5.972e24 # Mass of Earth in kg R_earth = 6.371e6 # Radius of Earth in meters # Initial conditions r_0 = R_earth + 100000 # Initial position (100 km above Earth's surface) v_0 = 1000 # Initial velocity in m/s (e.g., 1000 m/s upward) # Payload mass (just a placeholder value, can be any mass) m = 1000 # Mass of payload in kg # Time parameters dt = 1 # Time step in seconds t_max = 3600 # Total time in seconds (1 hour) num_steps = int(t_max / dt) # Initialize arrays to store results r = np.zeros(num_steps) # Array to store positions v = np.zeros(num_steps) # Array to store velocities t = np.linspace(0, t_max, num_steps) # Array of time values # Initial conditions r[0] = r_0 v[0] = v_0 # Numerical integration (Euler's method) for i in range(1, num_steps): # Gravitational force (F = G * M * m / r^2) F = -G * M * m / r[i-1]**2 # Force is attractive, hence the negative sign a = F / m # Acceleration due to gravity v[i] = v[i-1] + a * dt # Update velocity r[i] = r[i-1] + v[i-1] * dt # Update position # Stop simulation if the payload crashes into Earth (r < R_earth) if r[i] <= R_earth: print(f\"The payload crashed into Earth at time {t[i]} seconds.\") break # Plot the trajectory (position vs time) plt.plot(t[:i+1], r[:i+1]) # Plot only up to the crash point (if it crashes) plt.xlabel('Time (s)') plt.ylabel('Distance from Earth (m)') plt.title('Trajectory of a Freely Released Payload Near Earth') plt.grid(True) plt.show()","title":"Example Python Code to Simulate Trajectory"},{"location":"1%20Physics/2%20Gravity/Problem_3/#example-1-escape-and-orbital-velocities-of-planets","text":"Explanation: This table compares the escape and orbital (first cosmic) velocities for Earth, Mars, and Jupiter. These values are critical for satellite launches and interplanetary missions. Planet Escape Velocity (m/s) Orbital Velocity (m/s) Surface Radius (m) Mass (kg) Earth 11185.98 7909.68 6.371 \u00d7 10 6 5.972 \u00d7 10 24 Mars 5022.31 3551.31 3.396 \u00d7 10 6 0.64171 \u00d7 10 24 Jupiter 60199.98 42567.81 6.991 \u00d7 10 7 1.898 \u00d7 10 27","title":"Example 1: Escape and Orbital Velocities of Planets"},{"location":"1%20Physics/2%20Gravity/Problem_3/#example-2-orbit-type-based-on-initial-velocity","text":"Explanation: The following table shows how different initial velocities determine the type of orbit for a payload released near Earth. Initial Velocity (m/s) Initial Altitude (km) Orbit Type Description 3000 100 Elliptical Payload remains gravitationally bound to Earth. 5000 100 Parabolic Payload reaches escape velocity exactly. 7000 150 Hyperbolic Payload escapes Earth's gravity and continues outward. 8000 200 Parabolic Near escape, marginally hyperbolic trajectory.","title":"Example 2: Orbit Type Based on Initial Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_3/#example-3-required-speeds-for-orbital-insertion","text":"Explanation: This table compares the orbital and escape velocities required at a constant launch altitude for various planets. Planet Orbital Velocity (m/s) Escape Velocity (m/s) Launch Altitude (km) Earth 7909.68 11185.98 100 Mars 3551.31 5022.31 100 Jupiter 42567.81 60199.98 100 Conclusion: Payload trajectories near Earth vary based on initial speed and angle, resulting in orbits, reentry, or escape. Understanding these paths is key for satellite deployment and mission planning, combining gravity, motion laws, and simulation tools.","title":"Example 3: Required Speeds for Orbital Insertion"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 \ud83c\udf0a Interference Patterns on a Water Surface Motivation Interference occurs when waves from different sources overlap, creating new patterns. On a water surface, this is visible when ripples from different points meet, forming distinctive interference patterns. These can either reinforce each other (constructive interference) or cancel out (destructive interference). Studying these patterns deepens our understanding of wave behavior and is useful in physics, engineering, and real-world applications like acoustics and antenna design. Problem Statement Objective: Analyze the interference patterns formed on a water surface due to the superposition of waves emitted from point sources located at the vertices of a regular polygon. \ud83d\udcd0 Mathematical Model Single Disturbance Equation A circular wave originating from a point source located at position \\( \\vec{r}_i = (x_i, y_i) \\) can be described by the following wave equation: \\[ u_i(\\vec{r}, t) = A \\cdot \\cos\\left(k \\cdot |\\vec{r} - \\vec{r}_i| - \\omega t + \\phi_i\\right) \\] Where: \\( u_i(\\vec{r}, t) \\) : Displacement of the water surface at position \\( \\vec{r} = (x, y) \\) and time \\( t \\) \\( A \\) : Amplitude of the wave \\( k = \\frac{2\\pi}{\\lambda} \\) : Wave number, with \\( \\lambda \\) being the wavelength \\( \\omega = 2\\pi f \\) : Angular frequency, with \\( f \\) the frequency \\( |\\vec{r} - \\vec{r}_i| \\) : Distance between the field point \\( \\vec{r} \\) and the source at \\( \\vec{r}_i \\) \\( \\phi_i \\) : Initial phase of the wave from source \\( i \\) (assumed \\( \\phi_i = 0 \\) for all sources in this case) Superposition of Waves When there are \\( N \\) sources (e.g., located at the vertices of a regular polygon), the total displacement at any point ( \\ \ud83c\udf0a Superposition of Waves With \\( N \\) sources placed at the vertices of a regular polygon, the total displacement of the water surface at any position \\( \\vec{r} \\) and time \\( t \\) is given by the sum of the contributions from each source: \\[ u(\\vec{r}, t) = \\sum_{i=1}^{N} A \\cdot \\cos\\left(k \\cdot |\\vec{r} - \\vec{r}_i| - \\omega t\\right) \\] Where: - \\( N \\) : Number of sources - \\( \\vec{r}_i = (x_i, y_i) \\) : Position of the \\( i^\\text{th} \\) wave source - All sources are assumed to be coherent (same frequency and amplitude) and in phase. \u2699\ufe0f Simulation Parameters \\[ \\begin{aligned} &\\text{Polygon:} && \\text{Square (4 sources)} \\\\ &\\text{Radius:} && R = 1.0 \\, \\text{unit (distance from center to vertex)} \\\\ &\\text{Wavelength:} && \\lambda = 1.0 \\\\ &\\text{Frequency:} && f = 1.0 \\\\ &\\text{Amplitude:} && A = 1.0 \\end{aligned} \\] Python Code for Visualization import numpy as np import matplotlib.pyplot as plt # Parameters A = 1.0 # amplitude f = 1.0 # frequency lambda_ = 1.0 # wavelength omega = 2 * np.pi * f k = 2 * np.pi / lambda_ N = 4 # number of sources (square) R = 1.0 # radius of the polygon t = 0 # time snapshot # Create grid x = np.linspace(-3, 3, 500) y = np.linspace(-3, 3, 500) X, Y = np.meshgrid(x, y) U = np.zeros_like(X) # Compute source positions (square vertices) angles = np.linspace(0, 2 * np.pi, N, endpoint=False) source_positions = [(R * np.cos(a), R * np.sin(a)) for a in angles] # Superpose waves from each source for xi, yi in source_positions: r = np.sqrt((X - xi)**2 + (Y - yi)**2) U += A * np.cos(k * r - omega * t) # Plot plt.figure(figsize=(8, 6)) plt.contourf(X, Y, U, levels=100, cmap='seismic') plt.colorbar(label='Displacement') plt.scatter(*zip(*source_positions), color='black', marker='x', label='Sources') plt.title(\"Wave Interference Pattern from 4-Point Sources (Square)\") plt.xlabel(\"x\") plt.ylabel(\"y\") plt.axis('equal') plt.legend() plt.grid(False) plt.show() \ud83d\udd0d Observations and Explanation Constructive interference occurs where wave crests (or troughs) from all sources meet in phase , leading to amplified displacements . Destructive interference appears as dark or null regions , where the crest from one wave overlaps with the trough of another, resulting in cancellation . Due to the geometric symmetry of the square configuration, the resulting interference pattern also exhibits symmetry about the center and along its axes. As the number of sources \\( N \\) increases (e.g., pentagon, hexagon, etc.), the interference pattern becomes more intricate, and radial symmetry may emerge\u2014particularly in near-circular source arrangements. \ud83e\uddea Extensions Change \\( N \\) to 3 (triangle) , 5 (pentagon) , 6 (hexagon) , or more, to investigate how the geometry of the source layout affects the resulting pattern. Animate the wave field by updating the time variable \\( t \\) over successive frames to observe the temporal evolution of interference. Modify the wavelength \\( \\lambda \\) , frequency \\( f \\) , or introduce initial phase differences \\( \\phi_i \\) between sources to explore how these parameters influence the interference structure . \ud83d\udccc Wave Interference Model for 4-point Square \ud83d\udcc8 Contour Plot of the Interference Pattern \ud83d\udcca Line Plot at y = 0 \ud83d\udccb Simulation Parameters Table \ud83d\udcda Required Libraries import numpy as np import matplotlib.pyplot as plt from IPython.display import display, HTML # \u2699\ufe0f Simulation Parameters A = 1.0 # Amplitude f = 1.0 # Frequency (Hz) \u03bb = 1.0 # Wavelength \u03c9 = 2 * np.pi * f # Angular frequency k = 2 * np.pi / \u03bb # Wave number N = 4 # Number of sources (square) R = 1.0 # Radius from center to vertex t = 0 # Time snapshot # \ud83d\udcd0 Generate Source Positions (Square Vertices) angles = np.linspace(0, 2*np.pi, N, endpoint=False) source_positions = [(R * np.cos(a), R * np.sin(a)) for a in angles] # \ud83c\udf10 Grid Setup grid_size = 400 x = np.linspace(-3, 3, grid_size) y = np.linspace(-3, 3, grid_size) X, Y = np.meshgrid(x, y) U = np.zeros_like(X) # \ud83c\udf0a Superposition of Waves for (xi, yi) in source_positions: r = np.sqrt((X - xi)**2 + (Y - yi)**2) U += A * np.cos(k * r - \u03c9 * t) # \ud83c\udfa8 Interference Pattern Plot (Contour) plt.figure(figsize=(8, 6)) plt.contourf(X, Y, U, levels=100, cmap='viridis') plt.title(\"\ud83c\udf0a Interference Pattern from 4 Wave Sources (Square)\", fontsize=14) plt.xlabel(\"x-axis\") plt.ylabel(\"y-axis\") plt.colorbar(label=\"Displacement\") plt.grid(False) plt.show() import numpy as np import matplotlib.pyplot as plt # 1. Create a grid of points for x and y (as an example) # For simplicity, we'll create a grid from -10 to 10 in both x and y directions. x = np.linspace(-10, 10, 100) y = np.linspace(-10, 10, 100) # 2. Create a 2D displacement array (U) for demonstration purposes. # We'll create a simple example where the displacement is a function of x and y. X, Y = np.meshgrid(x, y) U = np.sin(X) * np.cos(Y) # Example displacement field # 3. Find the index corresponding to y = 0 y_index = np.argmin(np.abs(y - 0)) # Find closest y=0 # 4. Create the plot plt.figure(figsize=(8, 4)) plt.plot(x, U[y_index, :], color='crimson') # Plot displacement along y = 0 plt.title(\"\ud83d\udcc8 Displacement Profile Along y = 0\", fontsize=14) plt.xlabel(\"x-axis\") plt.ylabel(\"Displacement\") plt.grid(True) plt.show() \ud83d\udccb HTML Table of Parameters Wave Simulation Parameters body { font-family: Arial, sans-serif; } table { border-collapse: collapse; width: 60%; margin: 20px 0; } th, td { border: 1px solid #333; padding: 10px; text-align: center; } th { background-color: #444; color: white; } caption { caption-side: top; font-size: 1.4em; font-weight: bold; margin-bottom: 10px; } \ud83d\udccb Simulation Parameters Parameter Value Description A 1.0 Amplitude f 1.0 Hz Frequency \u03bb 1.0 Wavelength \u03c9 2\u03c0 Angular Frequency k 2\u03c0 Wave Number N 4 Number of Sources R 1.0 Radius from Center to Vertex","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-patterns-on-a-water-surface","text":"","title":"\ud83c\udf0a Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#motivation","text":"Interference occurs when waves from different sources overlap, creating new patterns. On a water surface, this is visible when ripples from different points meet, forming distinctive interference patterns. These can either reinforce each other (constructive interference) or cancel out (destructive interference). Studying these patterns deepens our understanding of wave behavior and is useful in physics, engineering, and real-world applications like acoustics and antenna design.","title":"Motivation"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-statement","text":"Objective: Analyze the interference patterns formed on a water surface due to the superposition of waves emitted from point sources located at the vertices of a regular polygon.","title":"Problem Statement"},{"location":"1%20Physics/3%20Waves/Problem_1/#mathematical-model","text":"","title":"\ud83d\udcd0 Mathematical Model"},{"location":"1%20Physics/3%20Waves/Problem_1/#single-disturbance-equation","text":"A circular wave originating from a point source located at position \\( \\vec{r}_i = (x_i, y_i) \\) can be described by the following wave equation: \\[ u_i(\\vec{r}, t) = A \\cdot \\cos\\left(k \\cdot |\\vec{r} - \\vec{r}_i| - \\omega t + \\phi_i\\right) \\] Where: \\( u_i(\\vec{r}, t) \\) : Displacement of the water surface at position \\( \\vec{r} = (x, y) \\) and time \\( t \\) \\( A \\) : Amplitude of the wave \\( k = \\frac{2\\pi}{\\lambda} \\) : Wave number, with \\( \\lambda \\) being the wavelength \\( \\omega = 2\\pi f \\) : Angular frequency, with \\( f \\) the frequency \\( |\\vec{r} - \\vec{r}_i| \\) : Distance between the field point \\( \\vec{r} \\) and the source at \\( \\vec{r}_i \\) \\( \\phi_i \\) : Initial phase of the wave from source \\( i \\) (assumed \\( \\phi_i = 0 \\) for all sources in this case)","title":"Single Disturbance Equation"},{"location":"1%20Physics/3%20Waves/Problem_1/#superposition-of-waves","text":"When there are \\( N \\) sources (e.g., located at the vertices of a regular polygon), the total displacement at any point ( \\","title":"Superposition of Waves"},{"location":"1%20Physics/3%20Waves/Problem_1/#superposition-of-waves_1","text":"With \\( N \\) sources placed at the vertices of a regular polygon, the total displacement of the water surface at any position \\( \\vec{r} \\) and time \\( t \\) is given by the sum of the contributions from each source: \\[ u(\\vec{r}, t) = \\sum_{i=1}^{N} A \\cdot \\cos\\left(k \\cdot |\\vec{r} - \\vec{r}_i| - \\omega t\\right) \\] Where: - \\( N \\) : Number of sources - \\( \\vec{r}_i = (x_i, y_i) \\) : Position of the \\( i^\\text{th} \\) wave source - All sources are assumed to be coherent (same frequency and amplitude) and in phase.","title":"\ud83c\udf0a Superposition of Waves"},{"location":"1%20Physics/3%20Waves/Problem_1/#simulation-parameters","text":"\\[ \\begin{aligned} &\\text{Polygon:} && \\text{Square (4 sources)} \\\\ &\\text{Radius:} && R = 1.0 \\, \\text{unit (distance from center to vertex)} \\\\ &\\text{Wavelength:} && \\lambda = 1.0 \\\\ &\\text{Frequency:} && f = 1.0 \\\\ &\\text{Amplitude:} && A = 1.0 \\end{aligned} \\] Python Code for Visualization import numpy as np import matplotlib.pyplot as plt # Parameters A = 1.0 # amplitude f = 1.0 # frequency lambda_ = 1.0 # wavelength omega = 2 * np.pi * f k = 2 * np.pi / lambda_ N = 4 # number of sources (square) R = 1.0 # radius of the polygon t = 0 # time snapshot # Create grid x = np.linspace(-3, 3, 500) y = np.linspace(-3, 3, 500) X, Y = np.meshgrid(x, y) U = np.zeros_like(X) # Compute source positions (square vertices) angles = np.linspace(0, 2 * np.pi, N, endpoint=False) source_positions = [(R * np.cos(a), R * np.sin(a)) for a in angles] # Superpose waves from each source for xi, yi in source_positions: r = np.sqrt((X - xi)**2 + (Y - yi)**2) U += A * np.cos(k * r - omega * t) # Plot plt.figure(figsize=(8, 6)) plt.contourf(X, Y, U, levels=100, cmap='seismic') plt.colorbar(label='Displacement') plt.scatter(*zip(*source_positions), color='black', marker='x', label='Sources') plt.title(\"Wave Interference Pattern from 4-Point Sources (Square)\") plt.xlabel(\"x\") plt.ylabel(\"y\") plt.axis('equal') plt.legend() plt.grid(False) plt.show()","title":"\u2699\ufe0f Simulation Parameters"},{"location":"1%20Physics/3%20Waves/Problem_1/#observations-and-explanation","text":"Constructive interference occurs where wave crests (or troughs) from all sources meet in phase , leading to amplified displacements . Destructive interference appears as dark or null regions , where the crest from one wave overlaps with the trough of another, resulting in cancellation . Due to the geometric symmetry of the square configuration, the resulting interference pattern also exhibits symmetry about the center and along its axes. As the number of sources \\( N \\) increases (e.g., pentagon, hexagon, etc.), the interference pattern becomes more intricate, and radial symmetry may emerge\u2014particularly in near-circular source arrangements.","title":"\ud83d\udd0d Observations and Explanation"},{"location":"1%20Physics/3%20Waves/Problem_1/#extensions","text":"Change \\( N \\) to 3 (triangle) , 5 (pentagon) , 6 (hexagon) , or more, to investigate how the geometry of the source layout affects the resulting pattern. Animate the wave field by updating the time variable \\( t \\) over successive frames to observe the temporal evolution of interference. Modify the wavelength \\( \\lambda \\) , frequency \\( f \\) , or introduce initial phase differences \\( \\phi_i \\) between sources to explore how these parameters influence the interference structure . \ud83d\udccc Wave Interference Model for 4-point Square \ud83d\udcc8 Contour Plot of the Interference Pattern \ud83d\udcca Line Plot at y = 0 \ud83d\udccb Simulation Parameters Table","title":"\ud83e\uddea Extensions"},{"location":"1%20Physics/3%20Waves/Problem_1/#required-libraries","text":"import numpy as np import matplotlib.pyplot as plt from IPython.display import display, HTML # \u2699\ufe0f Simulation Parameters A = 1.0 # Amplitude f = 1.0 # Frequency (Hz) \u03bb = 1.0 # Wavelength \u03c9 = 2 * np.pi * f # Angular frequency k = 2 * np.pi / \u03bb # Wave number N = 4 # Number of sources (square) R = 1.0 # Radius from center to vertex t = 0 # Time snapshot # \ud83d\udcd0 Generate Source Positions (Square Vertices) angles = np.linspace(0, 2*np.pi, N, endpoint=False) source_positions = [(R * np.cos(a), R * np.sin(a)) for a in angles] # \ud83c\udf10 Grid Setup grid_size = 400 x = np.linspace(-3, 3, grid_size) y = np.linspace(-3, 3, grid_size) X, Y = np.meshgrid(x, y) U = np.zeros_like(X) # \ud83c\udf0a Superposition of Waves for (xi, yi) in source_positions: r = np.sqrt((X - xi)**2 + (Y - yi)**2) U += A * np.cos(k * r - \u03c9 * t) # \ud83c\udfa8 Interference Pattern Plot (Contour) plt.figure(figsize=(8, 6)) plt.contourf(X, Y, U, levels=100, cmap='viridis') plt.title(\"\ud83c\udf0a Interference Pattern from 4 Wave Sources (Square)\", fontsize=14) plt.xlabel(\"x-axis\") plt.ylabel(\"y-axis\") plt.colorbar(label=\"Displacement\") plt.grid(False) plt.show() import numpy as np import matplotlib.pyplot as plt # 1. Create a grid of points for x and y (as an example) # For simplicity, we'll create a grid from -10 to 10 in both x and y directions. x = np.linspace(-10, 10, 100) y = np.linspace(-10, 10, 100) # 2. Create a 2D displacement array (U) for demonstration purposes. # We'll create a simple example where the displacement is a function of x and y. X, Y = np.meshgrid(x, y) U = np.sin(X) * np.cos(Y) # Example displacement field # 3. Find the index corresponding to y = 0 y_index = np.argmin(np.abs(y - 0)) # Find closest y=0 # 4. Create the plot plt.figure(figsize=(8, 4)) plt.plot(x, U[y_index, :], color='crimson') # Plot displacement along y = 0 plt.title(\"\ud83d\udcc8 Displacement Profile Along y = 0\", fontsize=14) plt.xlabel(\"x-axis\") plt.ylabel(\"Displacement\") plt.grid(True) plt.show()","title":"\ud83d\udcda Required Libraries"},{"location":"1%20Physics/3%20Waves/Problem_1/#html-table-of-parameters","text":"Wave Simulation Parameters body { font-family: Arial, sans-serif; } table { border-collapse: collapse; width: 60%; margin: 20px 0; } th, td { border: 1px solid #333; padding: 10px; text-align: center; } th { background-color: #444; color: white; } caption { caption-side: top; font-size: 1.4em; font-weight: bold; margin-bottom: 10px; } \ud83d\udccb Simulation Parameters Parameter Value Description A 1.0 Amplitude f 1.0 Hz Frequency \u03bb 1.0 Wavelength \u03c9 2\u03c0 Angular Frequency k 2\u03c0 Wave Number N 4 Number of Sources R 1.0 Radius from Center to Vertex","title":"\ud83d\udccb HTML Table of Parameters"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1 Simulating the Effects of the Lorentz Force \u26a1 Motivation: The Lorentz force describes the force experienced by a charged particle due to the presence of electric and magnetic fields. The Lorentz force is given by the equation: \\[ F = q(E + v \\times B) \\] Where: \\( q \\) is the charge of the particle, \\( E \\) is the electric field, \\( v \\) is the velocity of the particle, \\( B \\) is the magnetic field. This force governs the motion of charged particles in fields, and it plays a central role in many applications, such as plasma physics, particle accelerators, and astrophysics. Simulating this force helps to visualize and understand the complex trajectories of particles under various field conditions. 1. Exploration of Applications The Lorentz force is essential in various practical systems. Some notable applications include: Particle Accelerators: Devices like cyclotrons and synchrotrons use Lorentz force to accelerate particles. Mass Spectrometers: The Lorentz force helps in separating ions based on their mass-to-charge ratio. Plasma Confinement: Magnetic fields are used in fusion reactors like Tokamaks to confine plasma. In these systems, both electric and magnetic fields are used to control the motion of charged particles. The electric field accelerates the particles, while the magnetic field bends their paths, often resulting in circular or spiral motion. 2. Simulating Particle Motion We will simulate the trajectory of a charged particle under various field configurations. The following scenarios will be explored: 2.1 Particle Motion in a Uniform Magnetic Field The simplest case to start with is the motion of a charged particle in a uniform magnetic field. The particle will experience circular motion due to the Lorentz force. Python Code (Uniform Magnetic Field) import numpy as np import matplotlib.pyplot as plt # Constants q = 1.6e-19 # Charge of particle (Coulombs) m = 9.11e-31 # Mass of electron (kg) B = np.array([0, 0, 1]) # Uniform magnetic field along z-axis (Tesla) # Initial conditions v0 = np.array([1e5, 0, 0]) # Initial velocity (m/s) along x-axis r0 = np.array([0, 0, 0]) # Initial position at origin # Time setup dt = 1e-9 # Time step (seconds) T = 1e-6 # Total simulation time (seconds) steps = int(T / dt) # Number of steps # Initialize arrays to store positions and velocities r = np.zeros((steps, 3)) v = np.zeros((steps, 3)) r[0] = r0 v[0] = v0 # Euler's method for updating position and velocity for i in range(1, steps): # Lorentz force calculation F = q * np.cross(v[i-1], B) # Magnetic force (since E = 0) a = F / m # Acceleration (F = ma) # Update velocity and position v[i] = v[i-1] + a * dt r[i] = r[i-1] + v[i] * dt # Plot the trajectory in 3D fig = plt.figure(figsize=(10, 7)) ax = fig.add_subplot(111, projection='3d') ax.plot(r[:, 0], r[:, 1], r[:, 2], label=\"Particle Trajectory\", color='b') ax.set_xlabel(\"X Position (m)\") ax.set_ylabel(\"Y Position (m)\") ax.set_zlabel(\"Z Position (m)\") ax.set_title(\"Particle Trajectory in a Uniform Magnetic Field\") plt.legend() plt.show() In this code: The magnetic field is set to be along the z-axis. The particle starts with an initial velocity along the x-axis. The Euler method is used to solve the equations of motion and update the particle's position and velocity over time. The plot shows the circular trajectory of the particle under the influence of the magnetic field. 2. Particle Motion in Combined Electric and Magnetic Fields Now let's simulate the motion of a charged particle in both electric and magnetic fields. The particle's trajectory will be more complex, as it will exhibit helical motion due to the combined influence of the two fields. Python Code (Combined Electric and Magnetic Fields) import numpy as np import matplotlib.pyplot as plt # Electric field (along the x-axis) E = np.array([1e3, 0, 0]) # Electric field (V/m) # Modified Euler's method for combined E and B fields for i in range(1, steps): # Lorentz force calculation (E + v x B) F = q * (E + np.cross(v[i-1], B)) # Total Lorentz force a = F / m # Acceleration # Update velocity and position v[i] = v[i-1] + a * dt r[i] = r[i-1] + v[i] * dt # Plot the trajectory in 3D fig = plt.figure(figsize=(10, 7)) ax = fig.add_subplot(111, projection='3d') ax.plot(r[:, 0], r[:, 1], r[:, 2], label=\"Particle Trajectory with E and B Fields\", color='g') ax.set_xlabel(\"X Position (m)\") ax.set_ylabel(\"Y Position (m)\") ax.set_zlabel(\"Z Position (m)\") ax.set_title(\"Particle Trajectory in Combined Electric and Magnetic Fields\") plt.legend() plt.show() 2.2 Particle Motion in Combined Electric and Magnetic Fields In this simulation: The electric field \\( E \\) is applied along the x-axis. The particle experiences a helical motion due to the combination of the electric field, which accelerates the particle along the x-axis, and the magnetic field, which causes circular motion in the plane perpendicular to the field. 2.3 Particle Motion in Crossed Electric and Magnetic Fields Next, let's consider the case where the electric and magnetic fields are perpendicular to each other. This scenario is commonly referred to as \"crossed fields.\" Python Code (Crossed Electric and Magnetic Fields) import numpy as np import matplotlib.pyplot as plt # Crossed fields: Electric field along x-axis, magnetic field along y-axis E = np.array([1e3, 0, 0]) # Electric field (V/m) B = np.array([0, 1, 0]) # Magnetic field (Tesla) # Modified Euler's method for crossed fields for i in range(1, steps): # Lorentz force calculation (E + v x B) F = q * (E + np.cross(v[i-1], B)) # Total Lorentz force a = F / m # Acceleration # Update velocity and position v[i] = v[i-1] + a * dt r[i] = r[i-1] + v[i] * dt # Plot the trajectory in 3D fig = plt.figure(figsize=(10, 7)) ax = fig.add_subplot(111, projection='3d') ax.plot(r[:, 0], r[:, 1], r[:, 2], label=\"Particle Trajectory with Crossed Fields\", color='r') ax.set_xlabel(\"X Position (m)\") ax.set_ylabel(\"Y Position (m)\") ax.set_zlabel(\"Z Position (m)\") ax.set_title(\"Particle Trajectory in Crossed Electric and Magnetic Fields\") plt.legend() plt.show() In this scenario: The electric field \\( \\mathbf{E} \\) is along the x-axis : [ \\mathbf{E} = E_x \\hat{i} ] The magnetic field \\( \\mathbf{B} \\) is along the y-axis : [ \\mathbf{B} = B_y \\hat{j} ] The particle experiences a more complex path due to the crossed fields . This leads to a spiral motion in the combined electric and magnetic fields. 3. Parameter Exploration In each of the above simulations, you can explore how varying parameters such as: Magnetic field strength ( \\(B\\) ) : The strength of the magnetic field affects the radius of the particle's circular motion (Larmor radius). Increasing \\(B\\) will decrease the Larmor radius. Electric field strength ( \\(E\\) ) : The strength of the electric field influences the drift velocity of the particle, altering the trajectory of the motion. A stronger electric field will result in a larger drift velocity and a more pronounced directional motion along the electric field axis. Charge ( \\(q\\) ) : The charge of the particle determines the direction and magnitude of the forces experienced in the fields. A positively charged particle will be influenced differently than a negatively charged particle. Initial velocity ( \\(v_0\\) ) : The initial velocity of the particle defines its momentum and the speed of its motion. A higher \\(v_0\\) leads to a larger radius for circular motion and influences the particle's overall speed along the trajectory. Mass ( \\(m\\) ) : The mass of the particle affects its inertia, with a larger mass resulting in slower motion for the same force. A heavier particle will move more slowly through the fields compared to a lighter particle. 4. Visualization We created 3D visualizations of particle trajectories under different field configurations. The plots clearly show the particle's motion, highlighting phenomena such as: Larmor radius: The radius of the circular path of a charged particle in a magnetic field. Drift velocity: The velocity component along the direction of the electric field. HTML Table Example for Simulated Parameters If you need to display parameter values in a structured table (HTML format), here's an example of how you can present the results: Parameter Value Charge (q) 1.6e-19 C Mass (m) 9.11e-","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulating-the-effects-of-the-lorentz-force","text":"","title":"Simulating the Effects of the Lorentz Force \u26a1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#motivation","text":"The Lorentz force describes the force experienced by a charged particle due to the presence of electric and magnetic fields. The Lorentz force is given by the equation: \\[ F = q(E + v \\times B) \\] Where: \\( q \\) is the charge of the particle, \\( E \\) is the electric field, \\( v \\) is the velocity of the particle, \\( B \\) is the magnetic field. This force governs the motion of charged particles in fields, and it plays a central role in many applications, such as plasma physics, particle accelerators, and astrophysics. Simulating this force helps to visualize and understand the complex trajectories of particles under various field conditions.","title":"Motivation:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1-exploration-of-applications","text":"The Lorentz force is essential in various practical systems. Some notable applications include: Particle Accelerators: Devices like cyclotrons and synchrotrons use Lorentz force to accelerate particles. Mass Spectrometers: The Lorentz force helps in separating ions based on their mass-to-charge ratio. Plasma Confinement: Magnetic fields are used in fusion reactors like Tokamaks to confine plasma. In these systems, both electric and magnetic fields are used to control the motion of charged particles. The electric field accelerates the particles, while the magnetic field bends their paths, often resulting in circular or spiral motion.","title":"1. Exploration of Applications"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2-simulating-particle-motion","text":"We will simulate the trajectory of a charged particle under various field configurations. The following scenarios will be explored: 2.1 Particle Motion in a Uniform Magnetic Field The simplest case to start with is the motion of a charged particle in a uniform magnetic field. The particle will experience circular motion due to the Lorentz force.","title":"2. Simulating Particle Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#python-code-uniform-magnetic-field","text":"import numpy as np import matplotlib.pyplot as plt # Constants q = 1.6e-19 # Charge of particle (Coulombs) m = 9.11e-31 # Mass of electron (kg) B = np.array([0, 0, 1]) # Uniform magnetic field along z-axis (Tesla) # Initial conditions v0 = np.array([1e5, 0, 0]) # Initial velocity (m/s) along x-axis r0 = np.array([0, 0, 0]) # Initial position at origin # Time setup dt = 1e-9 # Time step (seconds) T = 1e-6 # Total simulation time (seconds) steps = int(T / dt) # Number of steps # Initialize arrays to store positions and velocities r = np.zeros((steps, 3)) v = np.zeros((steps, 3)) r[0] = r0 v[0] = v0 # Euler's method for updating position and velocity for i in range(1, steps): # Lorentz force calculation F = q * np.cross(v[i-1], B) # Magnetic force (since E = 0) a = F / m # Acceleration (F = ma) # Update velocity and position v[i] = v[i-1] + a * dt r[i] = r[i-1] + v[i] * dt # Plot the trajectory in 3D fig = plt.figure(figsize=(10, 7)) ax = fig.add_subplot(111, projection='3d') ax.plot(r[:, 0], r[:, 1], r[:, 2], label=\"Particle Trajectory\", color='b') ax.set_xlabel(\"X Position (m)\") ax.set_ylabel(\"Y Position (m)\") ax.set_zlabel(\"Z Position (m)\") ax.set_title(\"Particle Trajectory in a Uniform Magnetic Field\") plt.legend() plt.show() In this code: The magnetic field is set to be along the z-axis. The particle starts with an initial velocity along the x-axis. The Euler method is used to solve the equations of motion and update the particle's position and velocity over time. The plot shows the circular trajectory of the particle under the influence of the magnetic field.","title":"Python Code (Uniform Magnetic Field)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2-particle-motion-in-combined-electric-and-magnetic-fields","text":"Now let's simulate the motion of a charged particle in both electric and magnetic fields. The particle's trajectory will be more complex, as it will exhibit helical motion due to the combined influence of the two fields. Python Code (Combined Electric and Magnetic Fields) import numpy as np import matplotlib.pyplot as plt # Electric field (along the x-axis) E = np.array([1e3, 0, 0]) # Electric field (V/m) # Modified Euler's method for combined E and B fields for i in range(1, steps): # Lorentz force calculation (E + v x B) F = q * (E + np.cross(v[i-1], B)) # Total Lorentz force a = F / m # Acceleration # Update velocity and position v[i] = v[i-1] + a * dt r[i] = r[i-1] + v[i] * dt # Plot the trajectory in 3D fig = plt.figure(figsize=(10, 7)) ax = fig.add_subplot(111, projection='3d') ax.plot(r[:, 0], r[:, 1], r[:, 2], label=\"Particle Trajectory with E and B Fields\", color='g') ax.set_xlabel(\"X Position (m)\") ax.set_ylabel(\"Y Position (m)\") ax.set_zlabel(\"Z Position (m)\") ax.set_title(\"Particle Trajectory in Combined Electric and Magnetic Fields\") plt.legend() plt.show()","title":"2. Particle Motion in Combined Electric and Magnetic Fields"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#22-particle-motion-in-combined-electric-and-magnetic-fields","text":"In this simulation: The electric field \\( E \\) is applied along the x-axis. The particle experiences a helical motion due to the combination of the electric field, which accelerates the particle along the x-axis, and the magnetic field, which causes circular motion in the plane perpendicular to the field.","title":"2.2 Particle Motion in Combined Electric and Magnetic Fields"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#23-particle-motion-in-crossed-electric-and-magnetic-fields","text":"Next, let's consider the case where the electric and magnetic fields are perpendicular to each other. This scenario is commonly referred to as \"crossed fields.\" Python Code (Crossed Electric and Magnetic Fields) import numpy as np import matplotlib.pyplot as plt # Crossed fields: Electric field along x-axis, magnetic field along y-axis E = np.array([1e3, 0, 0]) # Electric field (V/m) B = np.array([0, 1, 0]) # Magnetic field (Tesla) # Modified Euler's method for crossed fields for i in range(1, steps): # Lorentz force calculation (E + v x B) F = q * (E + np.cross(v[i-1], B)) # Total Lorentz force a = F / m # Acceleration # Update velocity and position v[i] = v[i-1] + a * dt r[i] = r[i-1] + v[i] * dt # Plot the trajectory in 3D fig = plt.figure(figsize=(10, 7)) ax = fig.add_subplot(111, projection='3d') ax.plot(r[:, 0], r[:, 1], r[:, 2], label=\"Particle Trajectory with Crossed Fields\", color='r') ax.set_xlabel(\"X Position (m)\") ax.set_ylabel(\"Y Position (m)\") ax.set_zlabel(\"Z Position (m)\") ax.set_title(\"Particle Trajectory in Crossed Electric and Magnetic Fields\") plt.legend() plt.show() In this scenario: The electric field \\( \\mathbf{E} \\) is along the x-axis : [ \\mathbf{E} = E_x \\hat{i} ] The magnetic field \\( \\mathbf{B} \\) is along the y-axis : [ \\mathbf{B} = B_y \\hat{j} ] The particle experiences a more complex path due to the crossed fields . This leads to a spiral motion in the combined electric and magnetic fields.","title":"2.3 Particle Motion in Crossed Electric and Magnetic Fields"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#3-parameter-exploration","text":"In each of the above simulations, you can explore how varying parameters such as: Magnetic field strength ( \\(B\\) ) : The strength of the magnetic field affects the radius of the particle's circular motion (Larmor radius). Increasing \\(B\\) will decrease the Larmor radius. Electric field strength ( \\(E\\) ) : The strength of the electric field influences the drift velocity of the particle, altering the trajectory of the motion. A stronger electric field will result in a larger drift velocity and a more pronounced directional motion along the electric field axis. Charge ( \\(q\\) ) : The charge of the particle determines the direction and magnitude of the forces experienced in the fields. A positively charged particle will be influenced differently than a negatively charged particle. Initial velocity ( \\(v_0\\) ) : The initial velocity of the particle defines its momentum and the speed of its motion. A higher \\(v_0\\) leads to a larger radius for circular motion and influences the particle's overall speed along the trajectory. Mass ( \\(m\\) ) : The mass of the particle affects its inertia, with a larger mass resulting in slower motion for the same force. A heavier particle will move more slowly through the fields compared to a lighter particle.","title":"3. Parameter Exploration"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#4-visualization","text":"We created 3D visualizations of particle trajectories under different field configurations. The plots clearly show the particle's motion, highlighting phenomena such as: Larmor radius: The radius of the circular path of a charged particle in a magnetic field. Drift velocity: The velocity component along the direction of the electric field.","title":"4. Visualization"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#html-table-example-for-simulated-parameters","text":"If you need to display parameter values in a structured table (HTML format), here's an example of how you can present the results: Parameter Value Charge (q) 1.6e-19 C Mass (m) 9.11e-","title":"HTML Table Example for Simulated Parameters"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}